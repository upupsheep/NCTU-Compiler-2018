Terminals unused in grammar

   BOOLEAN


State 59 conflicts: 7 reduce/reduce
State 60 conflicts: 8 shift/reduce
State 87 conflicts: 18 reduce/reduce
State 88 conflicts: 18 reduce/reduce
State 89 conflicts: 18 reduce/reduce
State 134 conflicts: 8 shift/reduce, 15 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_list funct_def decl_and_def_list

    2 decl_list: decl_list var_decl
    3          | decl_list const_decl
    4          | decl_list funct_decl
    5          | %empty

    6 decl_and_def_list: decl_and_def_list var_decl
    7                  | decl_and_def_list const_decl
    8                  | decl_and_def_list funct_decl
    9                  | decl_and_def_list funct_def
   10                  | %empty

   11 $@1: %empty

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement

   13 $@2: %empty

   14 $@3: %empty

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE

   16 $@4: %empty

   17 funct_def: VOID ID L_PAREN R_PAREN $@4 compound_statement

   18 $@5: %empty

   19 $@6: %empty

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE

   21 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON
   22           | scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON
   23           | VOID ID L_PAREN R_PAREN SEMICOLON
   24           | VOID ID L_PAREN parameter_list R_PAREN SEMICOLON

   25 parameter_list: parameter_list COMMA scalar_type ID
   26               | parameter_list COMMA scalar_type array_decl
   27               | scalar_type array_decl
   28               | scalar_type ID

   29 var_decl: scalar_type identifier_list SEMICOLON

   30 identifier_list: identifier_list COMMA ID
   31                | identifier_list COMMA ID ASSIGN_OP logical_expression
   32                | identifier_list COMMA array_decl ASSIGN_OP initial_array
   33                | identifier_list COMMA array_decl
   34                | array_decl ASSIGN_OP initial_array
   35                | array_decl
   36                | ID ASSIGN_OP logical_expression
   37                | ID

   38 initial_array: L_BRACE literal_list R_BRACE

   39 literal_list: literal_list COMMA logical_expression
   40             | logical_expression
   41             | %empty

   42 const_decl: CONST scalar_type const_list SEMICOLON

   43 const_list: const_list COMMA ID ASSIGN_OP literal_const
   44           | ID ASSIGN_OP literal_const

   45 array_decl: ID dim

   46 dim: dim ML_BRACE INT_CONST MR_BRACE
   47    | ML_BRACE INT_CONST MR_BRACE

   48 $@7: %empty

   49 compound_statement: L_BRACE $@7 var_const_stmt_list R_BRACE

   50 var_const_stmt_list: var_const_stmt_list statement
   51                    | var_const_stmt_list var_decl
   52                    | var_const_stmt_list const_decl
   53                    | %empty

   54 statement: compound_statement
   55          | simple_statement
   56          | conditional_statement
   57          | while_statement
   58          | for_statement
   59          | function_invoke_statement
   60          | jump_statement

   61 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON
   62                 | PRINT logical_expression SEMICOLON
   63                 | READ variable_reference SEMICOLON

   64 conditional_statement: IF L_PAREN logical_expression R_PAREN compound_statement
   65                      | IF L_PAREN logical_expression R_PAREN compound_statement ELSE compound_statement

   66 $@8: %empty

   67 while_statement: WHILE $@8 L_PAREN logical_expression R_PAREN L_BRACE var_const_stmt_list R_BRACE

   68 $@9: %empty

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON

   70 $@10: %empty

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

   72 initial_expression_list: initial_expression
   73                        | %empty

   74 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP logical_expression
   75                   | initial_expression COMMA logical_expression
   76                   | logical_expression
   77                   | variable_reference ASSIGN_OP logical_expression

   78 control_expression_list: control_expression
   79                        | %empty

   80 control_expression: control_expression COMMA variable_reference ASSIGN_OP logical_expression
   81                   | control_expression COMMA logical_expression
   82                   | logical_expression
   83                   | variable_reference ASSIGN_OP logical_expression

   84 increment_expression_list: increment_expression
   85                          | %empty

   86 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP logical_expression
   87                     | increment_expression COMMA logical_expression
   88                     | logical_expression
   89                     | variable_reference ASSIGN_OP logical_expression

   90 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON
   91                          | ID L_PAREN R_PAREN SEMICOLON

   92 jump_statement: CONTINUE SEMICOLON
   93               | BREAK SEMICOLON
   94               | RETURN logical_expression SEMICOLON

   95 variable_reference: array_list
   96                   | ID

   97 logical_expression: logical_expression OR_OP logical_term
   98                   | logical_term

   99 logical_term: logical_term AND_OP logical_factor
  100             | logical_factor

  101 logical_factor: NOT_OP logical_factor
  102               | relation_expression

  103 relation_expression: arithmetic_expression relation_operator arithmetic_expression
  104                    | arithmetic_expression

  105 relation_operator: LT_OP
  106                  | LE_OP
  107                  | EQ_OP
  108                  | GE_OP
  109                  | GT_OP
  110                  | NE_OP

  111 arithmetic_expression: arithmetic_expression ADD_OP term
  112                      | arithmetic_expression SUB_OP term
  113                      | relation_expression
  114                      | term

  115 term: term MUL_OP factor
  116     | term DIV_OP factor
  117     | term MOD_OP factor
  118     | factor

  119 factor: variable_reference
  120       | SUB_OP factor
  121       | L_PAREN logical_expression R_PAREN
  122       | ID L_PAREN logical_expression_list R_PAREN
  123       | ID L_PAREN R_PAREN
  124       | literal_const

  125 logical_expression_list: logical_expression_list COMMA logical_expression
  126                        | logical_expression

  127 array_list: ID dimension

  128 dimension: dimension ML_BRACE logical_expression MR_BRACE
  129          | ML_BRACE logical_expression MR_BRACE

  130 scalar_type: INT
  131            | DOUBLE
  132            | STRING
  133            | BOOL
  134            | FLOAT

  135 literal_const: INT_CONST
  136              | SUB_OP INT_CONST
  137              | FLOAT_CONST
  138              | SUB_OP FLOAT_CONST
  139              | SCIENTIFIC
  140              | SUB_OP SCIENTIFIC
  141              | STR_CONST
  142              | TRUE
  143              | FALSE


Terminals, with rules where they appear

$end (0) 0
error (256)
ID (258) 12 15 17 20 21 22 23 24 25 28 30 31 36 37 43 44 45 90 91 96
    122 123 127
INT_CONST (259) 46 47 135 136
FLOAT_CONST (260) 137 138
SCIENTIFIC (261) 139 140
STR_CONST (262) 141
LE_OP (263) 106
NE_OP (264) 110
GE_OP (265) 108
EQ_OP (266) 107
AND_OP (267) 99
OR_OP (268) 97
READ (269) 63
BOOLEAN (270)
WHILE (271) 67 69
DO (272) 69
IF (273) 64 65
ELSE (274) 65
TRUE (275) 142
FALSE (276) 143
FOR (277) 71
INT (278) 130
PRINT (279) 62
BOOL (280) 133
VOID (281) 17 20 23 24
FLOAT (282) 134
DOUBLE (283) 131
STRING (284) 132
CONTINUE (285) 92
BREAK (286) 93
RETURN (287) 94
CONST (288) 42
L_PAREN (289) 12 15 17 20 21 22 23 24 64 65 67 69 71 90 91 121 122
    123
R_PAREN (290) 12 15 17 20 21 22 23 24 64 65 67 69 71 90 91 121 122
    123
COMMA (291) 25 26 30 31 32 33 39 43 74 75 80 81 86 87 125
SEMICOLON (292) 21 22 23 24 29 42 61 62 63 69 71 90 91 92 93 94
ML_BRACE (293) 46 47 128 129
MR_BRACE (294) 46 47 128 129
L_BRACE (295) 15 20 38 49 67 69 71
R_BRACE (296) 15 20 38 49 67 69 71
ADD_OP (297) 111
SUB_OP (298) 112 120 136 138 140
MUL_OP (299) 115
DIV_OP (300) 116
MOD_OP (301) 117
ASSIGN_OP (302) 31 32 34 36 43 44 61 74 77 80 83 86 89
LT_OP (303) 105
GT_OP (304) 109
NOT_OP (305) 101


Nonterminals, with rules where they appear

$accept (51)
    on left: 0
program (52)
    on left: 1, on right: 0
decl_list (53)
    on left: 2 3 4 5, on right: 1 2 3 4
decl_and_def_list (54)
    on left: 6 7 8 9 10, on right: 1 6 7 8 9
funct_def (55)
    on left: 12 15 17 20, on right: 1 9
$@1 (56)
    on left: 11, on right: 12
$@2 (57)
    on left: 13, on right: 15
$@3 (58)
    on left: 14, on right: 15
$@4 (59)
    on left: 16, on right: 17
$@5 (60)
    on left: 18, on right: 20
$@6 (61)
    on left: 19, on right: 20
funct_decl (62)
    on left: 21 22 23 24, on right: 4 8
parameter_list (63)
    on left: 25 26 27 28, on right: 15 20 22 24 25 26
var_decl (64)
    on left: 29, on right: 2 6 51
identifier_list (65)
    on left: 30 31 32 33 34 35 36 37, on right: 29 30 31 32 33
initial_array (66)
    on left: 38, on right: 32 34
literal_list (67)
    on left: 39 40 41, on right: 38 39
const_decl (68)
    on left: 42, on right: 3 7 52
const_list (69)
    on left: 43 44, on right: 42 43
array_decl (70)
    on left: 45, on right: 26 27 32 33 34 35
dim (71)
    on left: 46 47, on right: 45 46
compound_statement (72)
    on left: 49, on right: 12 17 54 64 65
$@7 (73)
    on left: 48, on right: 49
var_const_stmt_list (74)
    on left: 50 51 52 53, on right: 15 20 49 50 51 52 67 69 71
statement (75)
    on left: 54 55 56 57 58 59 60, on right: 50
simple_statement (76)
    on left: 61 62 63, on right: 55
conditional_statement (77)
    on left: 64 65, on right: 56
while_statement (78)
    on left: 67 69, on right: 57
$@8 (79)
    on left: 66, on right: 67
$@9 (80)
    on left: 68, on right: 69
for_statement (81)
    on left: 71, on right: 58
$@10 (82)
    on left: 70, on right: 71
initial_expression_list (83)
    on left: 72 73, on right: 71
initial_expression (84)
    on left: 74 75 76 77, on right: 72 74 75
control_expression_list (85)
    on left: 78 79, on right: 71
control_expression (86)
    on left: 80 81 82 83, on right: 78 80 81
increment_expression_list (87)
    on left: 84 85, on right: 71
increment_expression (88)
    on left: 86 87 88 89, on right: 84 86 87
function_invoke_statement (89)
    on left: 90 91, on right: 59
jump_statement (90)
    on left: 92 93 94, on right: 60
variable_reference (91)
    on left: 95 96, on right: 61 63 74 77 80 83 86 89 119
logical_expression (92)
    on left: 97 98, on right: 31 36 39 40 61 62 64 65 67 69 74 75 76
    77 80 81 82 83 86 87 88 89 94 97 121 125 126 128 129
logical_term (93)
    on left: 99 100, on right: 97 98 99
logical_factor (94)
    on left: 101 102, on right: 99 100 101
relation_expression (95)
    on left: 103 104, on right: 102 113
relation_operator (96)
    on left: 105 106 107 108 109 110, on right: 103
arithmetic_expression (97)
    on left: 111 112 113 114, on right: 103 104 111 112
term (98)
    on left: 115 116 117 118, on right: 111 112 114 115 116 117
factor (99)
    on left: 119 120 121 122 123 124, on right: 115 116 117 118 120
logical_expression_list (100)
    on left: 125 126, on right: 90 122 125
array_list (101)
    on left: 127, on right: 95
dimension (102)
    on left: 128 129, on right: 127 128
scalar_type (103)
    on left: 130 131 132 133 134, on right: 12 15 21 22 25 26 27 28
    29 42
literal_const (104)
    on left: 135 136 137 138 139 140 141 142 143, on right: 43 44 124


State 0

    0 $accept: . program $end

    $default  reduce using rule 5 (decl_list)

    program    go to state 1
    decl_list  go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: decl_list . funct_def decl_and_def_list
    2 decl_list: decl_list . var_decl
    3          | decl_list . const_decl
    4          | decl_list . funct_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    funct_def    go to state 11
    funct_decl   go to state 12
    var_decl     go to state 13
    const_decl   go to state 14
    scalar_type  go to state 15


State 3

    0 $accept: program $end .

    $default  accept


State 4

  130 scalar_type: INT .

    $default  reduce using rule 130 (scalar_type)


State 5

  133 scalar_type: BOOL .

    $default  reduce using rule 133 (scalar_type)


State 6

   17 funct_def: VOID . ID L_PAREN R_PAREN $@4 compound_statement
   20          | VOID . ID L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE
   23 funct_decl: VOID . ID L_PAREN R_PAREN SEMICOLON
   24           | VOID . ID L_PAREN parameter_list R_PAREN SEMICOLON

    ID  shift, and go to state 16


State 7

  134 scalar_type: FLOAT .

    $default  reduce using rule 134 (scalar_type)


State 8

  131 scalar_type: DOUBLE .

    $default  reduce using rule 131 (scalar_type)


State 9

  132 scalar_type: STRING .

    $default  reduce using rule 132 (scalar_type)


State 10

   42 const_decl: CONST . scalar_type const_list SEMICOLON

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 17


State 11

    1 program: decl_list funct_def . decl_and_def_list

    $default  reduce using rule 10 (decl_and_def_list)

    decl_and_def_list  go to state 18


State 12

    4 decl_list: decl_list funct_decl .

    $default  reduce using rule 4 (decl_list)


State 13

    2 decl_list: decl_list var_decl .

    $default  reduce using rule 2 (decl_list)


State 14

    3 decl_list: decl_list const_decl .

    $default  reduce using rule 3 (decl_list)


State 15

   12 funct_def: scalar_type . ID L_PAREN R_PAREN $@1 compound_statement
   15          | scalar_type . ID L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE
   21 funct_decl: scalar_type . ID L_PAREN R_PAREN SEMICOLON
   22           | scalar_type . ID L_PAREN parameter_list R_PAREN SEMICOLON
   29 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 19

    identifier_list  go to state 20
    array_decl       go to state 21


State 16

   17 funct_def: VOID ID . L_PAREN R_PAREN $@4 compound_statement
   20          | VOID ID . L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE
   23 funct_decl: VOID ID . L_PAREN R_PAREN SEMICOLON
   24           | VOID ID . L_PAREN parameter_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 22


State 17

   42 const_decl: CONST scalar_type . const_list SEMICOLON

    ID  shift, and go to state 23

    const_list  go to state 24


State 18

    1 program: decl_list funct_def decl_and_def_list .
    6 decl_and_def_list: decl_and_def_list . var_decl
    7                  | decl_and_def_list . const_decl
    8                  | decl_and_def_list . funct_decl
    9                  | decl_and_def_list . funct_def

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    $default  reduce using rule 1 (program)

    funct_def    go to state 25
    funct_decl   go to state 26
    var_decl     go to state 27
    const_decl   go to state 28
    scalar_type  go to state 15


State 19

   12 funct_def: scalar_type ID . L_PAREN R_PAREN $@1 compound_statement
   15          | scalar_type ID . L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE
   21 funct_decl: scalar_type ID . L_PAREN R_PAREN SEMICOLON
   22           | scalar_type ID . L_PAREN parameter_list R_PAREN SEMICOLON
   36 identifier_list: ID . ASSIGN_OP logical_expression
   37                | ID .
   45 array_decl: ID . dim

    L_PAREN    shift, and go to state 29
    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 37 (identifier_list)

    dim  go to state 32


State 20

   29 var_decl: scalar_type identifier_list . SEMICOLON
   30 identifier_list: identifier_list . COMMA ID
   31                | identifier_list . COMMA ID ASSIGN_OP logical_expression
   32                | identifier_list . COMMA array_decl ASSIGN_OP initial_array
   33                | identifier_list . COMMA array_decl

    COMMA      shift, and go to state 33
    SEMICOLON  shift, and go to state 34


State 21

   34 identifier_list: array_decl . ASSIGN_OP initial_array
   35                | array_decl .

    ASSIGN_OP  shift, and go to state 35

    $default  reduce using rule 35 (identifier_list)


State 22

   17 funct_def: VOID ID L_PAREN . R_PAREN $@4 compound_statement
   20          | VOID ID L_PAREN . parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE
   23 funct_decl: VOID ID L_PAREN . R_PAREN SEMICOLON
   24           | VOID ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 36

    parameter_list  go to state 37
    scalar_type     go to state 38


State 23

   44 const_list: ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 39


State 24

   42 const_decl: CONST scalar_type const_list . SEMICOLON
   43 const_list: const_list . COMMA ID ASSIGN_OP literal_const

    COMMA      shift, and go to state 40
    SEMICOLON  shift, and go to state 41


State 25

    9 decl_and_def_list: decl_and_def_list funct_def .

    $default  reduce using rule 9 (decl_and_def_list)


State 26

    8 decl_and_def_list: decl_and_def_list funct_decl .

    $default  reduce using rule 8 (decl_and_def_list)


State 27

    6 decl_and_def_list: decl_and_def_list var_decl .

    $default  reduce using rule 6 (decl_and_def_list)


State 28

    7 decl_and_def_list: decl_and_def_list const_decl .

    $default  reduce using rule 7 (decl_and_def_list)


State 29

   12 funct_def: scalar_type ID L_PAREN . R_PAREN $@1 compound_statement
   15          | scalar_type ID L_PAREN . parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE
   21 funct_decl: scalar_type ID L_PAREN . R_PAREN SEMICOLON
   22           | scalar_type ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 42

    parameter_list  go to state 43
    scalar_type     go to state 38


State 30

   47 dim: ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 44


State 31

   36 identifier_list: ID ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 56
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 32

   45 array_decl: ID dim .
   46 dim: dim . ML_BRACE INT_CONST MR_BRACE

    ML_BRACE  shift, and go to state 65

    $default  reduce using rule 45 (array_decl)


State 33

   30 identifier_list: identifier_list COMMA . ID
   31                | identifier_list COMMA . ID ASSIGN_OP logical_expression
   32                | identifier_list COMMA . array_decl ASSIGN_OP initial_array
   33                | identifier_list COMMA . array_decl

    ID  shift, and go to state 66

    array_decl  go to state 67


State 34

   29 var_decl: scalar_type identifier_list SEMICOLON .

    $default  reduce using rule 29 (var_decl)


State 35

   34 identifier_list: array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 68

    initial_array  go to state 69


State 36

   17 funct_def: VOID ID L_PAREN R_PAREN . $@4 compound_statement
   23 funct_decl: VOID ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 70

    $default  reduce using rule 16 ($@4)

    $@4  go to state 71


State 37

   20 funct_def: VOID ID L_PAREN parameter_list . R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE
   24 funct_decl: VOID ID L_PAREN parameter_list . R_PAREN SEMICOLON
   25 parameter_list: parameter_list . COMMA scalar_type ID
   26               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 72
    COMMA    shift, and go to state 73


State 38

   27 parameter_list: scalar_type . array_decl
   28               | scalar_type . ID

    ID  shift, and go to state 74

    array_decl  go to state 75


State 39

   44 const_list: ID ASSIGN_OP . literal_const

    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    SUB_OP       shift, and go to state 76

    literal_const  go to state 77


State 40

   43 const_list: const_list COMMA . ID ASSIGN_OP literal_const

    ID  shift, and go to state 78


State 41

   42 const_decl: CONST scalar_type const_list SEMICOLON .

    $default  reduce using rule 42 (const_decl)


State 42

   12 funct_def: scalar_type ID L_PAREN R_PAREN . $@1 compound_statement
   21 funct_decl: scalar_type ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 79

    $default  reduce using rule 11 ($@1)

    $@1  go to state 80


State 43

   15 funct_def: scalar_type ID L_PAREN parameter_list . R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE
   22 funct_decl: scalar_type ID L_PAREN parameter_list . R_PAREN SEMICOLON
   25 parameter_list: parameter_list . COMMA scalar_type ID
   26               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 81
    COMMA    shift, and go to state 73


State 44

   47 dim: ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 82


State 45

   96 variable_reference: ID .
  122 factor: ID . L_PAREN logical_expression_list R_PAREN
  123       | ID . L_PAREN R_PAREN
  127 array_list: ID . dimension

    L_PAREN   shift, and go to state 83
    ML_BRACE  shift, and go to state 84

    $default  reduce using rule 96 (variable_reference)

    dimension  go to state 85


State 46

  135 literal_const: INT_CONST .

    $default  reduce using rule 135 (literal_const)


State 47

  137 literal_const: FLOAT_CONST .

    $default  reduce using rule 137 (literal_const)


State 48

  139 literal_const: SCIENTIFIC .

    $default  reduce using rule 139 (literal_const)


State 49

  141 literal_const: STR_CONST .

    $default  reduce using rule 141 (literal_const)


State 50

  142 literal_const: TRUE .

    $default  reduce using rule 142 (literal_const)


State 51

  143 literal_const: FALSE .

    $default  reduce using rule 143 (literal_const)


State 52

  121 factor: L_PAREN . logical_expression R_PAREN

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 86
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 53

  120 factor: SUB_OP . factor
  136 literal_const: SUB_OP . INT_CONST
  138              | SUB_OP . FLOAT_CONST
  140              | SUB_OP . SCIENTIFIC

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 87
    FLOAT_CONST  shift, and go to state 88
    SCIENTIFIC   shift, and go to state 89
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    factor              go to state 90
    array_list          go to state 63
    literal_const       go to state 64


State 54

  101 logical_factor: NOT_OP . logical_factor

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 91
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 55

  119 factor: variable_reference .

    $default  reduce using rule 119 (factor)


State 56

   36 identifier_list: ID ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 36 (identifier_list)


State 57

   98 logical_expression: logical_term .
   99 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 93

    $default  reduce using rule 98 (logical_expression)


State 58

  100 logical_term: logical_factor .

    $default  reduce using rule 100 (logical_term)


State 59

  102 logical_factor: relation_expression .
  113 arithmetic_expression: relation_expression .

    AND_OP     reduce using rule 102 (logical_factor)
    AND_OP     [reduce using rule 113 (arithmetic_expression)]
    OR_OP      reduce using rule 102 (logical_factor)
    OR_OP      [reduce using rule 113 (arithmetic_expression)]
    R_PAREN    reduce using rule 102 (logical_factor)
    R_PAREN    [reduce using rule 113 (arithmetic_expression)]
    COMMA      reduce using rule 102 (logical_factor)
    COMMA      [reduce using rule 113 (arithmetic_expression)]
    SEMICOLON  reduce using rule 102 (logical_factor)
    SEMICOLON  [reduce using rule 113 (arithmetic_expression)]
    MR_BRACE   reduce using rule 102 (logical_factor)
    MR_BRACE   [reduce using rule 113 (arithmetic_expression)]
    R_BRACE    reduce using rule 102 (logical_factor)
    R_BRACE    [reduce using rule 113 (arithmetic_expression)]
    $default   reduce using rule 113 (arithmetic_expression)


State 60

  103 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  104                    | arithmetic_expression .
  111 arithmetic_expression: arithmetic_expression . ADD_OP term
  112                      | arithmetic_expression . SUB_OP term

    LE_OP   shift, and go to state 94
    NE_OP   shift, and go to state 95
    GE_OP   shift, and go to state 96
    EQ_OP   shift, and go to state 97
    ADD_OP  shift, and go to state 98
    SUB_OP  shift, and go to state 99
    LT_OP   shift, and go to state 100
    GT_OP   shift, and go to state 101

    LE_OP     [reduce using rule 104 (relation_expression)]
    NE_OP     [reduce using rule 104 (relation_expression)]
    GE_OP     [reduce using rule 104 (relation_expression)]
    EQ_OP     [reduce using rule 104 (relation_expression)]
    ADD_OP    [reduce using rule 104 (relation_expression)]
    SUB_OP    [reduce using rule 104 (relation_expression)]
    LT_OP     [reduce using rule 104 (relation_expression)]
    GT_OP     [reduce using rule 104 (relation_expression)]
    $default  reduce using rule 104 (relation_expression)

    relation_operator  go to state 102


State 61

  114 arithmetic_expression: term .
  115 term: term . MUL_OP factor
  116     | term . DIV_OP factor
  117     | term . MOD_OP factor

    MUL_OP  shift, and go to state 103
    DIV_OP  shift, and go to state 104
    MOD_OP  shift, and go to state 105

    $default  reduce using rule 114 (arithmetic_expression)


State 62

  118 term: factor .

    $default  reduce using rule 118 (term)


State 63

   95 variable_reference: array_list .

    $default  reduce using rule 95 (variable_reference)


State 64

  124 factor: literal_const .

    $default  reduce using rule 124 (factor)


State 65

   46 dim: dim ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 106


State 66

   30 identifier_list: identifier_list COMMA ID .
   31                | identifier_list COMMA ID . ASSIGN_OP logical_expression
   45 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 107

    $default  reduce using rule 30 (identifier_list)

    dim  go to state 32


State 67

   32 identifier_list: identifier_list COMMA array_decl . ASSIGN_OP initial_array
   33                | identifier_list COMMA array_decl .

    ASSIGN_OP  shift, and go to state 108

    $default  reduce using rule 33 (identifier_list)


State 68

   38 initial_array: L_BRACE . literal_list R_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    $default  reduce using rule 41 (literal_list)

    literal_list           go to state 109
    variable_reference     go to state 55
    logical_expression     go to state 110
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 69

   34 identifier_list: array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 34 (identifier_list)


State 70

   23 funct_decl: VOID ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 23 (funct_decl)


State 71

   17 funct_def: VOID ID L_PAREN R_PAREN $@4 . compound_statement

    L_BRACE  shift, and go to state 111

    compound_statement  go to state 112


State 72

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN . $@5 L_BRACE $@6 var_const_stmt_list R_BRACE
   24 funct_decl: VOID ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 113

    $default  reduce using rule 18 ($@5)

    $@5  go to state 114


State 73

   25 parameter_list: parameter_list COMMA . scalar_type ID
   26               | parameter_list COMMA . scalar_type array_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 115


State 74

   28 parameter_list: scalar_type ID .
   45 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 28 (parameter_list)

    dim  go to state 32


State 75

   27 parameter_list: scalar_type array_decl .

    $default  reduce using rule 27 (parameter_list)


State 76

  136 literal_const: SUB_OP . INT_CONST
  138              | SUB_OP . FLOAT_CONST
  140              | SUB_OP . SCIENTIFIC

    INT_CONST    shift, and go to state 116
    FLOAT_CONST  shift, and go to state 117
    SCIENTIFIC   shift, and go to state 118


State 77

   44 const_list: ID ASSIGN_OP literal_const .

    $default  reduce using rule 44 (const_list)


State 78

   43 const_list: const_list COMMA ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 119


State 79

   21 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 21 (funct_decl)


State 80

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 . compound_statement

    L_BRACE  shift, and go to state 111

    compound_statement  go to state 120


State 81

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN . $@2 L_BRACE $@3 var_const_stmt_list R_BRACE
   22 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121

    $default  reduce using rule 13 ($@2)

    $@2  go to state 122


State 82

   47 dim: ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 47 (dim)


State 83

  122 factor: ID L_PAREN . logical_expression_list R_PAREN
  123       | ID L_PAREN . R_PAREN

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    R_PAREN      shift, and go to state 123
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 124
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 125
    array_list               go to state 63
    literal_const            go to state 64


State 84

  129 dimension: ML_BRACE . logical_expression MR_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 126
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 85

  127 array_list: ID dimension .
  128 dimension: dimension . ML_BRACE logical_expression MR_BRACE

    ML_BRACE  shift, and go to state 127

    $default  reduce using rule 127 (array_list)


State 86

   97 logical_expression: logical_expression . OR_OP logical_term
  121 factor: L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 92
    R_PAREN  shift, and go to state 128


State 87

  135 literal_const: INT_CONST .
  136              | SUB_OP INT_CONST .

    LE_OP      reduce using rule 135 (literal_const)
    LE_OP      [reduce using rule 136 (literal_const)]
    NE_OP      reduce using rule 135 (literal_const)
    NE_OP      [reduce using rule 136 (literal_const)]
    GE_OP      reduce using rule 135 (literal_const)
    GE_OP      [reduce using rule 136 (literal_const)]
    EQ_OP      reduce using rule 135 (literal_const)
    EQ_OP      [reduce using rule 136 (literal_const)]
    AND_OP     reduce using rule 135 (literal_const)
    AND_OP     [reduce using rule 136 (literal_const)]
    OR_OP      reduce using rule 135 (literal_const)
    OR_OP      [reduce using rule 136 (literal_const)]
    R_PAREN    reduce using rule 135 (literal_const)
    R_PAREN    [reduce using rule 136 (literal_const)]
    COMMA      reduce using rule 135 (literal_const)
    COMMA      [reduce using rule 136 (literal_const)]
    SEMICOLON  reduce using rule 135 (literal_const)
    SEMICOLON  [reduce using rule 136 (literal_const)]
    MR_BRACE   reduce using rule 135 (literal_const)
    MR_BRACE   [reduce using rule 136 (literal_const)]
    R_BRACE    reduce using rule 135 (literal_const)
    R_BRACE    [reduce using rule 136 (literal_const)]
    ADD_OP     reduce using rule 135 (literal_const)
    ADD_OP     [reduce using rule 136 (literal_const)]
    SUB_OP     reduce using rule 135 (literal_const)
    SUB_OP     [reduce using rule 136 (literal_const)]
    MUL_OP     reduce using rule 135 (literal_const)
    MUL_OP     [reduce using rule 136 (literal_const)]
    DIV_OP     reduce using rule 135 (literal_const)
    DIV_OP     [reduce using rule 136 (literal_const)]
    MOD_OP     reduce using rule 135 (literal_const)
    MOD_OP     [reduce using rule 136 (literal_const)]
    LT_OP      reduce using rule 135 (literal_const)
    LT_OP      [reduce using rule 136 (literal_const)]
    GT_OP      reduce using rule 135 (literal_const)
    GT_OP      [reduce using rule 136 (literal_const)]
    $default   reduce using rule 135 (literal_const)


State 88

  137 literal_const: FLOAT_CONST .
  138              | SUB_OP FLOAT_CONST .

    LE_OP      reduce using rule 137 (literal_const)
    LE_OP      [reduce using rule 138 (literal_const)]
    NE_OP      reduce using rule 137 (literal_const)
    NE_OP      [reduce using rule 138 (literal_const)]
    GE_OP      reduce using rule 137 (literal_const)
    GE_OP      [reduce using rule 138 (literal_const)]
    EQ_OP      reduce using rule 137 (literal_const)
    EQ_OP      [reduce using rule 138 (literal_const)]
    AND_OP     reduce using rule 137 (literal_const)
    AND_OP     [reduce using rule 138 (literal_const)]
    OR_OP      reduce using rule 137 (literal_const)
    OR_OP      [reduce using rule 138 (literal_const)]
    R_PAREN    reduce using rule 137 (literal_const)
    R_PAREN    [reduce using rule 138 (literal_const)]
    COMMA      reduce using rule 137 (literal_const)
    COMMA      [reduce using rule 138 (literal_const)]
    SEMICOLON  reduce using rule 137 (literal_const)
    SEMICOLON  [reduce using rule 138 (literal_const)]
    MR_BRACE   reduce using rule 137 (literal_const)
    MR_BRACE   [reduce using rule 138 (literal_const)]
    R_BRACE    reduce using rule 137 (literal_const)
    R_BRACE    [reduce using rule 138 (literal_const)]
    ADD_OP     reduce using rule 137 (literal_const)
    ADD_OP     [reduce using rule 138 (literal_const)]
    SUB_OP     reduce using rule 137 (literal_const)
    SUB_OP     [reduce using rule 138 (literal_const)]
    MUL_OP     reduce using rule 137 (literal_const)
    MUL_OP     [reduce using rule 138 (literal_const)]
    DIV_OP     reduce using rule 137 (literal_const)
    DIV_OP     [reduce using rule 138 (literal_const)]
    MOD_OP     reduce using rule 137 (literal_const)
    MOD_OP     [reduce using rule 138 (literal_const)]
    LT_OP      reduce using rule 137 (literal_const)
    LT_OP      [reduce using rule 138 (literal_const)]
    GT_OP      reduce using rule 137 (literal_const)
    GT_OP      [reduce using rule 138 (literal_const)]
    $default   reduce using rule 137 (literal_const)


State 89

  139 literal_const: SCIENTIFIC .
  140              | SUB_OP SCIENTIFIC .

    LE_OP      reduce using rule 139 (literal_const)
    LE_OP      [reduce using rule 140 (literal_const)]
    NE_OP      reduce using rule 139 (literal_const)
    NE_OP      [reduce using rule 140 (literal_const)]
    GE_OP      reduce using rule 139 (literal_const)
    GE_OP      [reduce using rule 140 (literal_const)]
    EQ_OP      reduce using rule 139 (literal_const)
    EQ_OP      [reduce using rule 140 (literal_const)]
    AND_OP     reduce using rule 139 (literal_const)
    AND_OP     [reduce using rule 140 (literal_const)]
    OR_OP      reduce using rule 139 (literal_const)
    OR_OP      [reduce using rule 140 (literal_const)]
    R_PAREN    reduce using rule 139 (literal_const)
    R_PAREN    [reduce using rule 140 (literal_const)]
    COMMA      reduce using rule 139 (literal_const)
    COMMA      [reduce using rule 140 (literal_const)]
    SEMICOLON  reduce using rule 139 (literal_const)
    SEMICOLON  [reduce using rule 140 (literal_const)]
    MR_BRACE   reduce using rule 139 (literal_const)
    MR_BRACE   [reduce using rule 140 (literal_const)]
    R_BRACE    reduce using rule 139 (literal_const)
    R_BRACE    [reduce using rule 140 (literal_const)]
    ADD_OP     reduce using rule 139 (literal_const)
    ADD_OP     [reduce using rule 140 (literal_const)]
    SUB_OP     reduce using rule 139 (literal_const)
    SUB_OP     [reduce using rule 140 (literal_const)]
    MUL_OP     reduce using rule 139 (literal_const)
    MUL_OP     [reduce using rule 140 (literal_const)]
    DIV_OP     reduce using rule 139 (literal_const)
    DIV_OP     [reduce using rule 140 (literal_const)]
    MOD_OP     reduce using rule 139 (literal_const)
    MOD_OP     [reduce using rule 140 (literal_const)]
    LT_OP      reduce using rule 139 (literal_const)
    LT_OP      [reduce using rule 140 (literal_const)]
    GT_OP      reduce using rule 139 (literal_const)
    GT_OP      [reduce using rule 140 (literal_const)]
    $default   reduce using rule 139 (literal_const)


State 90

  120 factor: SUB_OP factor .

    $default  reduce using rule 120 (factor)


State 91

  101 logical_factor: NOT_OP logical_factor .

    $default  reduce using rule 101 (logical_factor)


State 92

   97 logical_expression: logical_expression OR_OP . logical_term

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_term           go to state 129
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 93

   99 logical_term: logical_term AND_OP . logical_factor

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 130
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 94

  106 relation_operator: LE_OP .

    $default  reduce using rule 106 (relation_operator)


State 95

  110 relation_operator: NE_OP .

    $default  reduce using rule 110 (relation_operator)


State 96

  108 relation_operator: GE_OP .

    $default  reduce using rule 108 (relation_operator)


State 97

  107 relation_operator: EQ_OP .

    $default  reduce using rule 107 (relation_operator)


State 98

  111 arithmetic_expression: arithmetic_expression ADD_OP . term

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    term                go to state 131
    factor              go to state 62
    array_list          go to state 63
    literal_const       go to state 64


State 99

  112 arithmetic_expression: arithmetic_expression SUB_OP . term

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    term                go to state 132
    factor              go to state 62
    array_list          go to state 63
    literal_const       go to state 64


State 100

  105 relation_operator: LT_OP .

    $default  reduce using rule 105 (relation_operator)


State 101

  109 relation_operator: GT_OP .

    $default  reduce using rule 109 (relation_operator)


State 102

  103 relation_expression: arithmetic_expression relation_operator . arithmetic_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference     go to state 55
    relation_expression    go to state 133
    arithmetic_expression  go to state 134
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 103

  115 term: term MUL_OP . factor

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    factor              go to state 135
    array_list          go to state 63
    literal_const       go to state 64


State 104

  116 term: term DIV_OP . factor

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    factor              go to state 136
    array_list          go to state 63
    literal_const       go to state 64


State 105

  117 term: term MOD_OP . factor

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53

    variable_reference  go to state 55
    factor              go to state 137
    array_list          go to state 63
    literal_const       go to state 64


State 106

   46 dim: dim ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 138


State 107

   31 identifier_list: identifier_list COMMA ID ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 139
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 108

   32 identifier_list: identifier_list COMMA array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 68

    initial_array  go to state 140


State 109

   38 initial_array: L_BRACE literal_list . R_BRACE
   39 literal_list: literal_list . COMMA logical_expression

    COMMA    shift, and go to state 141
    R_BRACE  shift, and go to state 142


State 110

   40 literal_list: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 40 (literal_list)


State 111

   49 compound_statement: L_BRACE . $@7 var_const_stmt_list R_BRACE

    $default  reduce using rule 48 ($@7)

    $@7  go to state 143


State 112

   17 funct_def: VOID ID L_PAREN R_PAREN $@4 compound_statement .

    $default  reduce using rule 17 (funct_def)


State 113

   24 funct_decl: VOID ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 24 (funct_decl)


State 114

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 . L_BRACE $@6 var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 144


State 115

   25 parameter_list: parameter_list COMMA scalar_type . ID
   26               | parameter_list COMMA scalar_type . array_decl

    ID  shift, and go to state 145

    array_decl  go to state 146


State 116

  136 literal_const: SUB_OP INT_CONST .

    $default  reduce using rule 136 (literal_const)


State 117

  138 literal_const: SUB_OP FLOAT_CONST .

    $default  reduce using rule 138 (literal_const)


State 118

  140 literal_const: SUB_OP SCIENTIFIC .

    $default  reduce using rule 140 (literal_const)


State 119

   43 const_list: const_list COMMA ID ASSIGN_OP . literal_const

    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    SUB_OP       shift, and go to state 76

    literal_const  go to state 147


State 120

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement .

    $default  reduce using rule 12 (funct_def)


State 121

   22 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 22 (funct_decl)


State 122

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 . L_BRACE $@3 var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 148


State 123

  123 factor: ID L_PAREN R_PAREN .

    $default  reduce using rule 123 (factor)


State 124

   97 logical_expression: logical_expression . OR_OP logical_term
  126 logical_expression_list: logical_expression .

    OR_OP  shift, and go to state 92

    $default  reduce using rule 126 (logical_expression_list)


State 125

  122 factor: ID L_PAREN logical_expression_list . R_PAREN
  125 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 149
    COMMA    shift, and go to state 150


State 126

   97 logical_expression: logical_expression . OR_OP logical_term
  129 dimension: ML_BRACE logical_expression . MR_BRACE

    OR_OP     shift, and go to state 92
    MR_BRACE  shift, and go to state 151


State 127

  128 dimension: dimension ML_BRACE . logical_expression MR_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 152
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 128

  121 factor: L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 121 (factor)


State 129

   97 logical_expression: logical_expression OR_OP logical_term .
   99 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 93

    $default  reduce using rule 97 (logical_expression)


State 130

   99 logical_term: logical_term AND_OP logical_factor .

    $default  reduce using rule 99 (logical_term)


State 131

  111 arithmetic_expression: arithmetic_expression ADD_OP term .
  115 term: term . MUL_OP factor
  116     | term . DIV_OP factor
  117     | term . MOD_OP factor

    MUL_OP  shift, and go to state 103
    DIV_OP  shift, and go to state 104
    MOD_OP  shift, and go to state 105

    $default  reduce using rule 111 (arithmetic_expression)


State 132

  112 arithmetic_expression: arithmetic_expression SUB_OP term .
  115 term: term . MUL_OP factor
  116     | term . DIV_OP factor
  117     | term . MOD_OP factor

    MUL_OP  shift, and go to state 103
    DIV_OP  shift, and go to state 104
    MOD_OP  shift, and go to state 105

    $default  reduce using rule 112 (arithmetic_expression)


State 133

  113 arithmetic_expression: relation_expression .

    $default  reduce using rule 113 (arithmetic_expression)


State 134

  103 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  103                    | arithmetic_expression relation_operator arithmetic_expression .
  104                    | arithmetic_expression .
  111 arithmetic_expression: arithmetic_expression . ADD_OP term
  112                      | arithmetic_expression . SUB_OP term

    LE_OP   shift, and go to state 94
    NE_OP   shift, and go to state 95
    GE_OP   shift, and go to state 96
    EQ_OP   shift, and go to state 97
    ADD_OP  shift, and go to state 98
    SUB_OP  shift, and go to state 99
    LT_OP   shift, and go to state 100
    GT_OP   shift, and go to state 101

    LE_OP      [reduce using rule 103 (relation_expression)]
    LE_OP      [reduce using rule 104 (relation_expression)]
    NE_OP      [reduce using rule 103 (relation_expression)]
    NE_OP      [reduce using rule 104 (relation_expression)]
    GE_OP      [reduce using rule 103 (relation_expression)]
    GE_OP      [reduce using rule 104 (relation_expression)]
    EQ_OP      [reduce using rule 103 (relation_expression)]
    EQ_OP      [reduce using rule 104 (relation_expression)]
    AND_OP     reduce using rule 103 (relation_expression)
    AND_OP     [reduce using rule 104 (relation_expression)]
    OR_OP      reduce using rule 103 (relation_expression)
    OR_OP      [reduce using rule 104 (relation_expression)]
    R_PAREN    reduce using rule 103 (relation_expression)
    R_PAREN    [reduce using rule 104 (relation_expression)]
    COMMA      reduce using rule 103 (relation_expression)
    COMMA      [reduce using rule 104 (relation_expression)]
    SEMICOLON  reduce using rule 103 (relation_expression)
    SEMICOLON  [reduce using rule 104 (relation_expression)]
    MR_BRACE   reduce using rule 103 (relation_expression)
    MR_BRACE   [reduce using rule 104 (relation_expression)]
    R_BRACE    reduce using rule 103 (relation_expression)
    R_BRACE    [reduce using rule 104 (relation_expression)]
    ADD_OP     [reduce using rule 103 (relation_expression)]
    ADD_OP     [reduce using rule 104 (relation_expression)]
    SUB_OP     [reduce using rule 103 (relation_expression)]
    SUB_OP     [reduce using rule 104 (relation_expression)]
    LT_OP      [reduce using rule 103 (relation_expression)]
    LT_OP      [reduce using rule 104 (relation_expression)]
    GT_OP      [reduce using rule 103 (relation_expression)]
    GT_OP      [reduce using rule 104 (relation_expression)]
    $default   reduce using rule 103 (relation_expression)

    relation_operator  go to state 102


State 135

  115 term: term MUL_OP factor .

    $default  reduce using rule 115 (term)


State 136

  116 term: term DIV_OP factor .

    $default  reduce using rule 116 (term)


State 137

  117 term: term MOD_OP factor .

    $default  reduce using rule 117 (term)


State 138

   46 dim: dim ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 46 (dim)


State 139

   31 identifier_list: identifier_list COMMA ID ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 31 (identifier_list)


State 140

   32 identifier_list: identifier_list COMMA array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 32 (identifier_list)


State 141

   39 literal_list: literal_list COMMA . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 153
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 142

   38 initial_array: L_BRACE literal_list R_BRACE .

    $default  reduce using rule 38 (initial_array)


State 143

   49 compound_statement: L_BRACE $@7 . var_const_stmt_list R_BRACE

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 154


State 144

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 L_BRACE . $@6 var_const_stmt_list R_BRACE

    $default  reduce using rule 19 ($@6)

    $@6  go to state 155


State 145

   25 parameter_list: parameter_list COMMA scalar_type ID .
   45 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 25 (parameter_list)

    dim  go to state 32


State 146

   26 parameter_list: parameter_list COMMA scalar_type array_decl .

    $default  reduce using rule 26 (parameter_list)


State 147

   43 const_list: const_list COMMA ID ASSIGN_OP literal_const .

    $default  reduce using rule 43 (const_list)


State 148

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 L_BRACE . $@3 var_const_stmt_list R_BRACE

    $default  reduce using rule 14 ($@3)

    $@3  go to state 156


State 149

  122 factor: ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 122 (factor)


State 150

  125 logical_expression_list: logical_expression_list COMMA . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 157
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 151

  129 dimension: ML_BRACE logical_expression MR_BRACE .

    $default  reduce using rule 129 (dimension)


State 152

   97 logical_expression: logical_expression . OR_OP logical_term
  128 dimension: dimension ML_BRACE logical_expression . MR_BRACE

    OR_OP     shift, and go to state 92
    MR_BRACE  shift, and go to state 158


State 153

   39 literal_list: literal_list COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 39 (literal_list)


State 154

   49 compound_statement: L_BRACE $@7 var_const_stmt_list . R_BRACE
   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 169

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 155

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 . var_const_stmt_list R_BRACE

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 182


State 156

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 . var_const_stmt_list R_BRACE

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 183


State 157

   97 logical_expression: logical_expression . OR_OP logical_term
  125 logical_expression_list: logical_expression_list COMMA logical_expression .

    OR_OP  shift, and go to state 92

    $default  reduce using rule 125 (logical_expression_list)


State 158

  128 dimension: dimension ML_BRACE logical_expression MR_BRACE .

    $default  reduce using rule 128 (dimension)


State 159

   90 function_invoke_statement: ID . L_PAREN logical_expression_list R_PAREN SEMICOLON
   91                          | ID . L_PAREN R_PAREN SEMICOLON
   96 variable_reference: ID .
  127 array_list: ID . dimension

    L_PAREN   shift, and go to state 184
    ML_BRACE  shift, and go to state 84

    $default  reduce using rule 96 (variable_reference)

    dimension  go to state 85


State 160

   63 simple_statement: READ . variable_reference SEMICOLON

    ID  shift, and go to state 185

    variable_reference  go to state 186
    array_list          go to state 63


State 161

   67 while_statement: WHILE . $@8 L_PAREN logical_expression R_PAREN L_BRACE var_const_stmt_list R_BRACE

    $default  reduce using rule 66 ($@8)

    $@8  go to state 187


State 162

   69 while_statement: DO . L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 188


State 163

   64 conditional_statement: IF . L_PAREN logical_expression R_PAREN compound_statement
   65                      | IF . L_PAREN logical_expression R_PAREN compound_statement ELSE compound_statement

    L_PAREN  shift, and go to state 189


State 164

   71 for_statement: FOR . $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    $default  reduce using rule 70 ($@10)

    $@10  go to state 190


State 165

   62 simple_statement: PRINT . logical_expression SEMICOLON

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 191
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 166

   92 jump_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 192


State 167

   93 jump_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 193


State 168

   94 jump_statement: RETURN . logical_expression SEMICOLON

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 194
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 169

   49 compound_statement: L_BRACE $@7 var_const_stmt_list R_BRACE .

    $default  reduce using rule 49 (compound_statement)


State 170

   51 var_const_stmt_list: var_const_stmt_list var_decl .

    $default  reduce using rule 51 (var_const_stmt_list)


State 171

   52 var_const_stmt_list: var_const_stmt_list const_decl .

    $default  reduce using rule 52 (var_const_stmt_list)


State 172

   54 statement: compound_statement .

    $default  reduce using rule 54 (statement)


State 173

   50 var_const_stmt_list: var_const_stmt_list statement .

    $default  reduce using rule 50 (var_const_stmt_list)


State 174

   55 statement: simple_statement .

    $default  reduce using rule 55 (statement)


State 175

   56 statement: conditional_statement .

    $default  reduce using rule 56 (statement)


State 176

   57 statement: while_statement .

    $default  reduce using rule 57 (statement)


State 177

   58 statement: for_statement .

    $default  reduce using rule 58 (statement)


State 178

   59 statement: function_invoke_statement .

    $default  reduce using rule 59 (statement)


State 179

   60 statement: jump_statement .

    $default  reduce using rule 60 (statement)


State 180

   61 simple_statement: variable_reference . ASSIGN_OP logical_expression SEMICOLON

    ASSIGN_OP  shift, and go to state 195


State 181

   29 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 196

    identifier_list  go to state 20
    array_decl       go to state 21


State 182

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list . R_BRACE
   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 197

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 183

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list . R_BRACE
   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 198

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 184

   90 function_invoke_statement: ID L_PAREN . logical_expression_list R_PAREN SEMICOLON
   91                          | ID L_PAREN . R_PAREN SEMICOLON

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    R_PAREN      shift, and go to state 199
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 124
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 200
    array_list               go to state 63
    literal_const            go to state 64


State 185

   96 variable_reference: ID .
  127 array_list: ID . dimension

    ML_BRACE  shift, and go to state 84

    $default  reduce using rule 96 (variable_reference)

    dimension  go to state 85


State 186

   63 simple_statement: READ variable_reference . SEMICOLON

    SEMICOLON  shift, and go to state 201


State 187

   67 while_statement: WHILE $@8 . L_PAREN logical_expression R_PAREN L_BRACE var_const_stmt_list R_BRACE

    L_PAREN  shift, and go to state 202


State 188

   69 while_statement: DO L_BRACE . $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 68 ($@9)

    $@9  go to state 203


State 189

   64 conditional_statement: IF L_PAREN . logical_expression R_PAREN compound_statement
   65                      | IF L_PAREN . logical_expression R_PAREN compound_statement ELSE compound_statement

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 204
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 190

   71 for_statement: FOR $@10 . L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    L_PAREN  shift, and go to state 205


State 191

   62 simple_statement: PRINT logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 92
    SEMICOLON  shift, and go to state 206


State 192

   92 jump_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 92 (jump_statement)


State 193

   93 jump_statement: BREAK SEMICOLON .

    $default  reduce using rule 93 (jump_statement)


State 194

   94 jump_statement: RETURN logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 92
    SEMICOLON  shift, and go to state 207


State 195

   61 simple_statement: variable_reference ASSIGN_OP . logical_expression SEMICOLON

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 208
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 196

   36 identifier_list: ID . ASSIGN_OP logical_expression
   37                | ID .
   45 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 37 (identifier_list)

    dim  go to state 32


State 197

   20 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@5 L_BRACE $@6 var_const_stmt_list R_BRACE .

    $default  reduce using rule 20 (funct_def)


State 198

   15 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 L_BRACE $@3 var_const_stmt_list R_BRACE .

    $default  reduce using rule 15 (funct_def)


State 199

   91 function_invoke_statement: ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 209


State 200

   90 function_invoke_statement: ID L_PAREN logical_expression_list . R_PAREN SEMICOLON
  125 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 210
    COMMA    shift, and go to state 150


State 201

   63 simple_statement: READ variable_reference SEMICOLON .

    $default  reduce using rule 63 (simple_statement)


State 202

   67 while_statement: WHILE $@8 L_PAREN . logical_expression R_PAREN L_BRACE var_const_stmt_list R_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 211
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 203

   69 while_statement: DO L_BRACE $@9 . var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 212


State 204

   64 conditional_statement: IF L_PAREN logical_expression . R_PAREN compound_statement
   65                      | IF L_PAREN logical_expression . R_PAREN compound_statement ELSE compound_statement
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 92
    R_PAREN  shift, and go to state 213


State 205

   71 for_statement: FOR $@10 L_PAREN . initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    $default  reduce using rule 73 (initial_expression_list)

    initial_expression_list  go to state 214
    initial_expression       go to state 215
    variable_reference       go to state 216
    logical_expression       go to state 217
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    array_list               go to state 63
    literal_const            go to state 64


State 206

   62 simple_statement: PRINT logical_expression SEMICOLON .

    $default  reduce using rule 62 (simple_statement)


State 207

   94 jump_statement: RETURN logical_expression SEMICOLON .

    $default  reduce using rule 94 (jump_statement)


State 208

   61 simple_statement: variable_reference ASSIGN_OP logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 92
    SEMICOLON  shift, and go to state 218


State 209

   91 function_invoke_statement: ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 91 (function_invoke_statement)


State 210

   90 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 219


State 211

   67 while_statement: WHILE $@8 L_PAREN logical_expression . R_PAREN L_BRACE var_const_stmt_list R_BRACE
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 92
    R_PAREN  shift, and go to state 220


State 212

   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl
   69 while_statement: DO L_BRACE $@9 var_const_stmt_list . R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 221

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 213

   64 conditional_statement: IF L_PAREN logical_expression R_PAREN . compound_statement
   65                      | IF L_PAREN logical_expression R_PAREN . compound_statement ELSE compound_statement

    L_BRACE  shift, and go to state 111

    compound_statement  go to state 222


State 214

   71 for_statement: FOR $@10 L_PAREN initial_expression_list . SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    SEMICOLON  shift, and go to state 223


State 215

   72 initial_expression_list: initial_expression .
   74 initial_expression: initial_expression . COMMA variable_reference ASSIGN_OP logical_expression
   75                   | initial_expression . COMMA logical_expression

    COMMA  shift, and go to state 224

    $default  reduce using rule 72 (initial_expression_list)


State 216

   77 initial_expression: variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 225

    $default  reduce using rule 119 (factor)


State 217

   76 initial_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 76 (initial_expression)


State 218

   61 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON .

    $default  reduce using rule 61 (simple_statement)


State 219

   90 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON .

    $default  reduce using rule 90 (function_invoke_statement)


State 220

   67 while_statement: WHILE $@8 L_PAREN logical_expression R_PAREN . L_BRACE var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 226


State 221

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE . WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    WHILE  shift, and go to state 227


State 222

   64 conditional_statement: IF L_PAREN logical_expression R_PAREN compound_statement .
   65                      | IF L_PAREN logical_expression R_PAREN compound_statement . ELSE compound_statement

    ELSE  shift, and go to state 228

    $default  reduce using rule 64 (conditional_statement)


State 223

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON . control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    $default  reduce using rule 79 (control_expression_list)

    control_expression_list  go to state 229
    control_expression       go to state 230
    variable_reference       go to state 231
    logical_expression       go to state 232
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    array_list               go to state 63
    literal_const            go to state 64


State 224

   74 initial_expression: initial_expression COMMA . variable_reference ASSIGN_OP logical_expression
   75                   | initial_expression COMMA . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 233
    logical_expression     go to state 234
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 225

   77 initial_expression: variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 235
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 226

   67 while_statement: WHILE $@8 L_PAREN logical_expression R_PAREN L_BRACE . var_const_stmt_list R_BRACE

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 236


State 227

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE . L_PAREN logical_expression R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 237


State 228

   65 conditional_statement: IF L_PAREN logical_expression R_PAREN compound_statement ELSE . compound_statement

    L_BRACE  shift, and go to state 111

    compound_statement  go to state 238


State 229

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list . SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    SEMICOLON  shift, and go to state 239


State 230

   78 control_expression_list: control_expression .
   80 control_expression: control_expression . COMMA variable_reference ASSIGN_OP logical_expression
   81                   | control_expression . COMMA logical_expression

    COMMA  shift, and go to state 240

    $default  reduce using rule 78 (control_expression_list)


State 231

   83 control_expression: variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 241

    $default  reduce using rule 119 (factor)


State 232

   82 control_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 82 (control_expression)


State 233

   74 initial_expression: initial_expression COMMA variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 242

    $default  reduce using rule 119 (factor)


State 234

   75 initial_expression: initial_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 75 (initial_expression)


State 235

   77 initial_expression: variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 77 (initial_expression)


State 236

   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl
   67 while_statement: WHILE $@8 L_PAREN logical_expression R_PAREN L_BRACE var_const_stmt_list . R_BRACE

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 243

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 237

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN . logical_expression R_PAREN SEMICOLON

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 244
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 238

   65 conditional_statement: IF L_PAREN logical_expression R_PAREN compound_statement ELSE compound_statement .

    $default  reduce using rule 65 (conditional_statement)


State 239

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON . increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    $default  reduce using rule 85 (increment_expression_list)

    increment_expression_list  go to state 245
    increment_expression       go to state 246
    variable_reference         go to state 247
    logical_expression         go to state 248
    logical_term               go to state 57
    logical_factor             go to state 58
    relation_expression        go to state 59
    arithmetic_expression      go to state 60
    term                       go to state 61
    factor                     go to state 62
    array_list                 go to state 63
    literal_const              go to state 64


State 240

   80 control_expression: control_expression COMMA . variable_reference ASSIGN_OP logical_expression
   81                   | control_expression COMMA . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 249
    logical_expression     go to state 250
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 241

   83 control_expression: variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 251
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 242

   74 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 252
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 243

   67 while_statement: WHILE $@8 L_PAREN logical_expression R_PAREN L_BRACE var_const_stmt_list R_BRACE .

    $default  reduce using rule 67 (while_statement)


State 244

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression . R_PAREN SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 92
    R_PAREN  shift, and go to state 253


State 245

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list . R_PAREN L_BRACE var_const_stmt_list R_BRACE

    R_PAREN  shift, and go to state 254


State 246

   84 increment_expression_list: increment_expression .
   86 increment_expression: increment_expression . COMMA variable_reference ASSIGN_OP logical_expression
   87                     | increment_expression . COMMA logical_expression

    COMMA  shift, and go to state 255

    $default  reduce using rule 84 (increment_expression_list)


State 247

   89 increment_expression: variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 256

    $default  reduce using rule 119 (factor)


State 248

   88 increment_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 88 (increment_expression)


State 249

   80 control_expression: control_expression COMMA variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 257

    $default  reduce using rule 119 (factor)


State 250

   81 control_expression: control_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 81 (control_expression)


State 251

   83 control_expression: variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 83 (control_expression)


State 252

   74 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 74 (initial_expression)


State 253

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 258


State 254

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN . L_BRACE var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 259


State 255

   86 increment_expression: increment_expression COMMA . variable_reference ASSIGN_OP logical_expression
   87                     | increment_expression COMMA . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 260
    logical_expression     go to state 261
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 256

   89 increment_expression: variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 262
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 257

   80 control_expression: control_expression COMMA variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 263
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 258

   69 while_statement: DO L_BRACE $@9 var_const_stmt_list R_BRACE WHILE L_PAREN logical_expression R_PAREN SEMICOLON .

    $default  reduce using rule 69 (while_statement)


State 259

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE . var_const_stmt_list R_BRACE

    $default  reduce using rule 53 (var_const_stmt_list)

    var_const_stmt_list  go to state 264


State 260

   86 increment_expression: increment_expression COMMA variable_reference . ASSIGN_OP logical_expression
  119 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 265

    $default  reduce using rule 119 (factor)


State 261

   87 increment_expression: increment_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 87 (increment_expression)


State 262

   89 increment_expression: variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 89 (increment_expression)


State 263

   80 control_expression: control_expression COMMA variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 80 (control_expression)


State 264

   50 var_const_stmt_list: var_const_stmt_list . statement
   51                    | var_const_stmt_list . var_decl
   52                    | var_const_stmt_list . const_decl
   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list . R_BRACE

    ID        shift, and go to state 159
    READ      shift, and go to state 160
    WHILE     shift, and go to state 161
    DO        shift, and go to state 162
    IF        shift, and go to state 163
    FOR       shift, and go to state 164
    INT       shift, and go to state 4
    PRINT     shift, and go to state 165
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 166
    BREAK     shift, and go to state 167
    RETURN    shift, and go to state 168
    CONST     shift, and go to state 10
    L_BRACE   shift, and go to state 111
    R_BRACE   shift, and go to state 266

    var_decl                   go to state 170
    const_decl                 go to state 171
    compound_statement         go to state 172
    statement                  go to state 173
    simple_statement           go to state 174
    conditional_statement      go to state 175
    while_statement            go to state 176
    for_statement              go to state 177
    function_invoke_statement  go to state 178
    jump_statement             go to state 179
    variable_reference         go to state 180
    array_list                 go to state 63
    scalar_type                go to state 181


State 265

   86 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 45
    INT_CONST    shift, and go to state 46
    FLOAT_CONST  shift, and go to state 47
    SCIENTIFIC   shift, and go to state 48
    STR_CONST    shift, and go to state 49
    TRUE         shift, and go to state 50
    FALSE        shift, and go to state 51
    L_PAREN      shift, and go to state 52
    SUB_OP       shift, and go to state 53
    NOT_OP       shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 267
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    array_list             go to state 63
    literal_const          go to state 64


State 266

   71 for_statement: FOR $@10 L_PAREN initial_expression_list SEMICOLON control_expression_list SEMICOLON increment_expression_list R_PAREN L_BRACE var_const_stmt_list R_BRACE .

    $default  reduce using rule 71 (for_statement)


State 267

   86 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 92

    $default  reduce using rule 86 (increment_expression)
